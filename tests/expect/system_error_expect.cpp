/*
 * This file has been auto-generated by CppUMockGen v0.6.
 *
 * Contents will NOT be preserved if it is regenerated!!!
 *
 * Generation options: -s c++20
 */

#include "system_error_expect.hpp"

namespace expect { namespace Panic$ {
MockExpectedCall& powerUp()
{
    return powerUp(1);
}
MockExpectedCall& powerUp(unsigned int __numCalls__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Panic::powerUp");
    return __expectedCall__;
}
} }

namespace expect { namespace Panic$ {
MockExpectedCall& throwError(CppUMockGen::Parameter<const Panic::ErrorCode> code, bool __return__)
{
    return throwError(1, code, __return__);
}
MockExpectedCall& throwError(unsigned int __numCalls__, CppUMockGen::Parameter<const Panic::ErrorCode> code, bool __return__)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Panic::throwError");
    if(code.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withIntParameter("code", static_cast<int>(code.getValue())); }
    __expectedCall__.andReturnValue(__return__);
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} }

namespace expect { namespace Panic$ {
MockExpectedCall& assertion(CppUMockGen::Parameter<const bool> predicate, CppUMockGen::Parameter<const Panic::ErrorCode> code)
{
    return assertion(1, predicate, code);
}
MockExpectedCall& assertion(unsigned int __numCalls__, CppUMockGen::Parameter<const bool> predicate, CppUMockGen::Parameter<const Panic::ErrorCode> code)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Panic::assertion");
    if(predicate.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withBoolParameter("predicate", predicate.getValue()); }
    if(code.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withIntParameter("code", static_cast<int>(code.getValue())); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} }

namespace expect { namespace Panic$ {
MockExpectedCall& getLastError(Panic::ErrorCode __return__)
{
    return getLastError(1, __return__);
}
MockExpectedCall& getLastError(unsigned int __numCalls__, Panic::ErrorCode __return__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Panic::getLastError");
    __expectedCall__.andReturnValue(static_cast<int>(__return__));
    return __expectedCall__;
}
} }

namespace expect { namespace Panic$ {
MockExpectedCall& resetError()
{
    return resetError(1);
}
MockExpectedCall& resetError(unsigned int __numCalls__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Panic::resetError");
    return __expectedCall__;
}
} }

namespace expect { namespace Panic$ {
MockExpectedCall& registerHandler(CppUMockGen::Parameter<const Panic::ErrorCode> code, CppUMockGen::Parameter<Panic::ErrorCallback&> handler)
{
    return registerHandler(1, code, handler);
}
MockExpectedCall& registerHandler(unsigned int __numCalls__, CppUMockGen::Parameter<const Panic::ErrorCode> code, CppUMockGen::Parameter<Panic::ErrorCallback&> handler)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Panic::registerHandler");
    if(code.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withIntParameter("code", static_cast<int>(code.getValue())); }
    if(handler.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withParameterOfType("Panic::ErrorCallback", "handler", &handler.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} }

